#include<bits/stdc++.h>
using namespace std;

/*

6 7
3 2 6
5 3 1
0 1 5
1 5 -3
1 2 -2
3 4 -2
2 4 3
0

*/



class node
{
public:
int u,v,wt;
node(int first,int second,int weight)
{
u=first;
v=second;
wt=weight;
}
};

int main()
{
int N,m;
cin>>N>>m;
vector<node> edges;
for(int i=0;i<m;i++)
{
int u,v,wt;
cin>>u>>v>>wt;
edges.push_back(node(u,v,wt));
}

int src;
cin>>src;
vector<int>dist(N+1,1000000);
dist[src]=0;

for(int i=1;i<=N-1;i++) //bellman ford algorithm gives us shortest distance for each node in N-1
{
for(auto it:edges)
{
if(dist[it.u]+it.wt<dist[it.v])
{
dist[it.v]=dist[it.u]+it.wt;

}
}
}

//after running N-1 times we should get the minimum distance for each node

//but in case if we get another value which is less than previous wt even after running N-1 times that means there is negative cycle

int fl=0;
for(auto it:edges)
{
if(dist[it.u]+it.wt<dist[it.v])
{
cout<<"Negative Cycle\n";
fl=1;
break;
}
}

if(!fl)
{
for(int i=0;i<N;i++)
{
cout<<i<<" "<<dist[i]<<endl;
}}
return 0;
}
